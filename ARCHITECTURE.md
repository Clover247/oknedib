# Архітектура Проєкту "Oknedib CRM"

Цей документ описує архітектурні принципи та підходи, які будуть використовуватись при розробці CRM-системи. Дотримання цих правил є обов'язковим для підтримки чистоти, масштабованості та консистентності кодової бази.

## 1. Загальні Принципи

- **Мова:** TypeScript для бекенду та фронтенду.
- **Монорепозиторій (Monorepo):** В майбутньому, для спрощення управління, проєкт буде організовано як монорепозиторій (наприклад, за допомогою `pnpm workspaces`), де `backend` та `frontend` будуть окремими пакетами. На початковому етапі вони будуть просто двома директоріями в корені проєкту.
- **Консистентність:** Код повинен відповідати правилам, описаним в цьому документі, та існуючому стилю коду.

---

## 2. Backend (NestJS) - Clean Architecture + DDD

Ми використовуємо гібридний підхід, що поєднує принципи **Чистої Архітектури** та **Предметно-орієнтованого Проектування (DDD)**. Це дозволяє нам ізолювати бізнес-логіку від фреймворку та зовнішніх залежностей.

### Рівні Архітектури (Layers)

Залежності можуть йти тільки ззовні всередину. Внутрішні рівні нічого не знають про зовнішні.

```
  +---------------------------------------------------+
  |                 Presentation (API)                |
  | (Controllers, DTOs, Guards)                       |
  +---------------------------------------------------+
                      |
                      v
  +---------------------------------------------------+
  |                  Application                      |
  | (Use Cases / Services, Application Logic)         |
  +---------------------------------------------------+
                      |
                      v
  +---------------------------------------------------+
  |                     Domain                        |
  | (Entities, Aggregates, Repositories Interfaces)   |
  +---------------------------------------------------+
                      |
                      v
  +---------------------------------------------------+
  |                  Infrastructure                   |
  | (DB, TypeORM Repositories, External Services)     |
  +---------------------------------------------------+
```

1.  **`Domain` (Предметна область):**
    *   **Призначення:** Ядро нашої бізнес-логіки. Містить правила, які є універсальними для бізнесу, незалежно від того, як вони використовуються.
    *   **Вміст:**
        *   `Entities`: Об'єкти з унікальним ідентифікатором (`User`, `Project`).
        *   `Value Objects`: Об'єкти без ідентифікатора, що описують характеристику (`Money`, `Address`).
        *   `Aggregates`: Кластери пов'язаних сутностей, що розглядаються як єдине ціле (`Project` з його `Tasks`).
        *   `Repository Interfaces`: Абстрактні інтерфейси для доступу до даних (`IProjectRepository`), реалізація яких знаходиться в інфраструктурному шарі.
    *   **Правило:** Цей шар не залежить ні від чого.

2.  **`Application` (Прикладний рівень):**
    *   **Призначення:** Оркеструє потік даних та викликає логіку домену для виконання конкретних сценаріїв використання (Use Cases).
    *   **Вміст:**
        *   `Use Cases` або `Services` (`CreateProjectUseCase`, `AddCommentToTaskService`).
        *   `DTOs (Data Transfer Objects)` для вхідних та вихідних даних сервісів.
    *   **Правило:** Залежить тільки від `Domain`.

3.  **`Infrastructure` (Інфраструктурний рівень):**
    *   **Призначення:** Реалізація зовнішніх залежностей: бази даних, файлові сховища, сторонні API.
    *   **Вміст:**
        *   Реалізація репозиторіїв (`ProjectRepository` з TypeORM).
        *   Підключення до БД, конфігурація.
        *   Клієнти для сторонніх сервісів (AWS S3, Google Calendar API).
    *   **Правило:** Залежить від `Domain` (реалізує його інтерфейси), але `Domain` про нього нічого не знає (принцип інверсії залежностей).

4.  **`Presentation` (Рівень представлення):**
    *   **Призначення:** Точка входу в додаток. В нашому випадку - це NestJS API.
    *   **Вміст:**
        *   `Controllers`: Приймають HTTP-запити.
        *   `DTOs`: Валідація вхідних даних (`class-validator`).
        *   `Guards`, `Pipes`, `Interceptors`.
    *   **Правило:** Залежить від `Application`. Викликає Use Cases з прикладного рівня.

### Структура Директорій (Backend)

```
/backend
└── src
    ├── modules
    │   └── projects
    │       ├── 1-presentation
    │       │   ├── controllers
    │       │   │   └── projects.controller.ts
    │       │   ├── guards
    │       │   └── dtos
    │       │       ├── create-project.dto.ts
    │       │       └── update-project.dto.ts
    │       ├── 2-application
    │       │   ├── use-cases
    │       │   │   ├── create-project.use-case.ts
    │       │   │   └── get-project.use-case.ts
    │       │   └── services
    │       ├── 3-domain
    │       │   ├── entities
    │       │   │   └── project.entity.ts
    │       │   ├── aggregates
    │       │   └── repositories
    │       │       └── project.repository.interface.ts
    │       └── 4-infrastructure
    │           ├── repositories
    │           │   └── project.typeorm.repository.ts
    │           └── mappers
    ├── shared
    │   ├── domain
    │   ├── application
    │   └── infrastructure
    └── main.ts
```

---

## 3. Frontend (React) - Feature-Sliced Design (FSD)

FSD організовує код навколо бізнес-функціоналу, а не технічних ролей. Це робить кодову базу передбачуваною та легкою для навігації.

### Рівні Архітектури (Slices)

Правило залежностей: кожен шар може використовувати тільки шари, що знаходяться нижче.

```
+---------------------------------------------------+
|                        app                        |
| (Роутер, глобальні стилі, провайдери)             |
+---------------------------------------------------+
                      |
                      v
+---------------------------------------------------+
|                       pages                       |
| (Сторінки додатку, композиція віджетів)           |
+---------------------------------------------------+
                      |
                      v
+---------------------------------------------------+
|                      widgets                      |
| (Композиційні блоки, "шапка", "список проектів")  |
+---------------------------------------------------+
                      |
                      v
+---------------------------------------------------+
|                      features                     |
| (Бізнес-логіка, "створити проект", "логін")       |
+---------------------------------------------------+
                      |
                      v
+---------------------------------------------------+
|                      entities                     |
| (Бізнес-сутності, "Проект", "Користувач")         |
+---------------------------------------------------+
                      |
                      v
+---------------------------------------------------+
|                       shared                      |
| (Перевикористовувані компоненти, UI-kit, API)     |
+---------------------------------------------------+
```

### Структура Директорій (Frontend)

```
/frontend
└── src
    ├── app
    │   ├── providers
    │   ├── styles
    │   └── index.tsx
    ├── pages
    │   ├── project-list
    │   │   └── index.tsx
    │   └── project-details
    │       └── index.tsx
    ├── widgets
    │   ├── header
    │   ├── project-list
    │   └── create-project-modal
    ├── features
    │   ├── auth-by-email
    │   ├── create-project
    │   └── filter-projects
    ├── entities
    │   ├── project
    │   │   ├── model (slice, selectors, thunks)
    │   │   ├── ui (ProjectCard, ProjectRow)
    │   │   └── api
    │   └── user
    └── shared
        ├── ui (Button, Input, Modal)
        ├── lib (hooks, helpers)
        ├── config (роути, константи)
        └── api (базові інстанси axios, RTK Query)
```

---

## 4. Подальші кроки

1.  **Налаштування середовища:** Створення базової структури директорій для `backend` та `frontend`.
2.  **Ініціалізація проєктів:** `npm init` або `pnpm init` для обох частин.
3.  **Встановлення залежностей:** NestJS для бекенду, React + Vite для фронтенду.
4.  **Налаштування лінтерів:** ESLint + Prettier для консистентного стилю коду.
5.  **Створення першого модуля/фічі:** Почнемо з автентифікації, як з найбільш базової та незалежної частини.
